name: Continuous deployment

on:
  push:
    branches:
      - main
    paths-ignore:
      - '.devcontainer/**'
      - '.github/**'
  workflow_dispatch:
    inputs:
      # This option is primarily for development purpose.
      republish-all:
        default: false
        description: 'Republish all packages'
        type: boolean

# Do not cancel current run. This is because we are using ${{ github.sha }} to determine what to publish.
# If current run is cancelled, we will not publish packages for the current run.
concurrency: continuous-deployment

env:
  node-version: lts/Hydrogen
  publish-tag: release/vnext

jobs:
  build:
    name: Build
    outputs:
      should-publish: ${{ steps.list-packages.outputs.should-publish }}
    runs-on: ubuntu-latest
    steps:
      - name: 'Sanity check: Valid action variables'
        run: if [[ "${{ vars.NPM_REGISTRY_URL_AZURE_DEV_OPS }}" != */ ]]; then exit 1; fi
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - name: Use Node.js ${{ env.node-version }}
        uses: actions/setup-node@v3
        with:
          always-auth: true
          cache: npm
          node-version: ${{ env.node-version }}
          # CyberEO: When building production bits, we have to use an internal NPM instead of NPMJS.
          registry-url: ${{ vars.NPM_REGISTRY_URL_AZURE_DEV_OPS }}
      - name: Redirect package-lock.json
        run: |
          cat package-lock.json | jq -r '.packages = (.packages | with_entries(.value = (.value | (if ((.link | not) and .resolved) then (.resolved = "${{ vars.NPM_REGISTRY_URL_AZURE_DEV_OPS }}" + (.resolved | ltrimstr("https://registry.npmjs.org/"))) else . end))))' > package-lock.json.tmp
          mv package-lock.json.tmp package-lock.json
      - # `package-versions.json` is the source of truth.
        env:
          # CyberEO: When building production bits, we have to use an internal NPM instead of NPMJS.
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN_AZURE_DEV_OPS_READ }}
        name: Append commitish to package version
        run: |
          BRANCH=`git branch --show-current`

          echo {} > package-versions.json

          for i in `cat package.json | jq -r '.workspaces | join("\n")'`
          do
            COMMITTER_DATE=`git log --date=format:%Y%m%d --pretty=format:'%cd' -1 ./$i/`
            COMMITTER_DATE_IN_ISO8601=`git log --pretty=format:'%cI' -1 ./$i/`
            LONG_COMMITISH=`git log --pretty=format:'%H' -1 ./$i/`
            SHORT_COMMITISH=`git log --pretty=format:'%h' -1 ./$i/`

            cat ./$i/package.json | jq -r .version | xargs -L1 npx semver $1 --increment prerelease -n false --preid $BRANCH.$COMMITTER_DATE.$SHORT_COMMITISH | xargs -L1 npm version --no-git-tag-version --workspace $i $1 && true || exit 1

            cat ./package-versions.json | jq --arg branch $BRANCH --arg committerDateInISO8601 $COMMITTER_DATE_IN_ISO8601 --arg longCommitish $LONG_COMMITISH --arg shortCommitish $SHORT_COMMITISH --arg path ./$i/ --argfile packageJSON ./$i/package.json -rS '. + { ($packageJSON.name): { branch: $branch, committerDate: $committerDateInISO8601, longCommitish: $longCommitish, path: $path, shortCommitish: $shortCommitish, shouldPublish: (${{ inputs.republish-all || false }} // ($longCommitish == "${{ github.sha }}")), tarball: ("./" + $packageJSON.name + "-" + $packageJSON.version + ".tgz"), version: $packageJSON.version } }' > ./package-versions.json.tmp && true || exit 1

            mv ./package-versions.json.tmp ./package-versions.json && true || exit 1
          done
      - name: Show versions file
        run: cat package-versions.json
      - env:
          # CyberEO: When building production bits, we have to use an internal NPM instead of NPMJS.
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN_AZURE_DEV_OPS_READ }}
        run: npm install
      - name: Build
        run: npm run build --if-present --workspaces=true
      - name: Pack tarballs
        run: npm pack --pack-destination=$PWD --workspaces=true
      - name: 'Sanity check: has packed all tarballs'
        run: |
          for i in `cat package-versions.json | jq -r '.[] | .tarball'`
          do
            compgen -G $i
          done
      - name: Upload tarball artifact
        uses: actions/upload-artifact@v3
        with:
          name: package-versions
          path: ./package-versions.json
      - id: list-packages
        name: List publishing packages
        run: |
          cat package-versions.json | jq -r 'map(select(.shouldPublish))'
          echo should-publish=`cat package-versions.json | jq -r 'map(select(.shouldPublish)) | if length > 0 then true else false end'` >> $GITHUB_OUTPUT
      - id: move-packages
        if: ${{ steps.list-packages.outputs.should-publish == 'true' }}
        name: Move publishing packages to /publishing/
        run: |
          mkdir -p ./publishing/

          for i in `cat package-versions.json | jq -r '.[] | select(.shouldPublish) | .tarball'`
          do
            mv $i ./publishing/
          done
      - if: ${{ steps.list-packages.outputs.should-publish == 'true' }}
        name: Upload publishing packages artifact
        uses: actions/upload-artifact@v3
        with:
          name: publishing-packages
          path: ./publishing/
      - name: Summary
        run: |
          echo The following packages will be published: >> $GITHUB_STEP_SUMMARY

          cat package-versions.json | jq -r 'map(select(.shouldPublish)) | .[] | ("- `" + (.tarball | ltrimstr("./")) + "` ([Link to source](${{ github.server_url }}/${{ github.repository }}/tree/" + .longCommitish + "/" + (.path | ltrimstr("./")) + "))")' >> $GITHUB_STEP_SUMMARY

          echo \<details\>\<summary\>Content of \<code\>package-versions.json\</code\>\</summary\> >> $GITHUB_STEP_SUMMARY
          echo >> $GITHUB_STEP_SUMMARY
          echo \`\`\`json >> $GITHUB_STEP_SUMMARY
          cat package-versions.json >> $GITHUB_STEP_SUMMARY
          echo \`\`\` >> $GITHUB_STEP_SUMMARY
          echo \</details\> >> $GITHUB_STEP_SUMMARY

  upload-release-asset:
    if: ${{ needs.build.outputs.should-publish == 'true' }}
    name: Upload release asset
    needs:
      - build
    permissions:
      contents: write # "contents" is required for modifying releases.
    runs-on: ubuntu-latest
    steps:
      - name: Download publishing packages artifact
        uses: actions/download-artifact@v3
        with:
          name: publishing-packages
      - name: List all publishing packages
        run: ls -l ./*.tgz
      - env:
          GH_TOKEN: ${{ github.token }}
        name: Upload packages to GitHub "${{ env.publish-tag }}" release
        run: |
          for i in `ls *.tgz -1`
          do
            gh release delete-asset ${{ env.publish-tag }} $i --repo ${{ github.repository }} || true
            gh release upload ${{ env.publish-tag }} $i --repo ${{ github.repository }}
          done
      - name: Summary
        run: echo Release at https://github.com/${{ github.repository }}/releases/tag/${{ env.publish-tag }} >> $GITHUB_STEP_SUMMARY

  update-release:
    if: ${{ needs.build.outputs.should-publish == 'true' }}
    name: Update release
    needs:
      - upload-release-asset
    permissions:
      contents: write
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Fetch all tags.
      - name: Update tag
        run: |
          git tag -d ${{ env.publish-tag }} || true
          git tag ${{ env.publish-tag }}
          git push origin :${{ env.publish-tag }} || true
          git push origin ${{ env.publish-tag }}
      - # Update release after re-pushing a new tag.
        env:
          GH_TOKEN: ${{ github.token }}
        name: Update release
        run: gh release edit ${{ env.publish-tag }} --draft=false --prerelease --repo ${{ github.repository }}
      - name: Summary
        run: echo Tag at https://github.com/${{ github.repository }}/tree/${{ env.publish-tag }} >> $GITHUB_STEP_SUMMARY
