name: Continuous deployment (matrix as workflow state)
run-name: "${{ github.event_name != 'push' && format('Continuous deployment: {0} on {1}', github.event_name, github.ref_name) || null }}"

on:
  push:
    branches:
      - main
    paths-ignore:
      - '.azdo/**'
      - '.devcontainer/**'
      - '.github/**'
  workflow_dispatch:
    inputs:
      # TODO: Find a way to set it to true for "push".
      use-secure-feed:
        default: true
        description: Use secure feed (required for production)
        required: true
        type: boolean

# Do not cancel current run. This is because we are using ${{ github.sha }} to determine what to publish.
# If current run is cancelled, we will not publish packages for the current run.
# TODO: Fix this name
concurrency: continuous-deployment2

env:
  node-version: lts/Hydrogen
  publish-tag: release/vnext

jobs:
  prepare:
    name: Prepare
    outputs:
      matrix: ${{ steps.write-outputs.outputs.matrix }}
    runs-on: ubuntu-latest
    steps:
      - name: Set up Node.js ${{ env.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.node-version }}
      - if: ${{ inputs.use-secure-feed }}
        name: Set up secure feed
        run: npx https://aka.ms/EnableSecureFeed
        shell: bash
      - run: npm install --global --ignore-scripts semver@latest # Ignore scripts to prevent malicious scripts.

      # We intentionally checkout after enable secure feed.
      # This will speed up secure feed setup significantly as it don't need to patch package-lock.json.
      # But we also need to be super careful we don't run any NPM commands that would fetch the registry. We are insecure here.
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Infinite depth required for commitish
      - id: build-matrix
        name: Build matrix
        run: |
          branch=`git branch --show-current` && true || exit 1

          echo [] > /tmp/matrix.json

          for package_path in `cat ./package.json | jq -r '.workspaces | join("\n")'`
          do
            # committer_date=20230815-110805
            committer_date=`git log --date=format:%Y%m%d-%H%M%S --pretty=format:'%cd' -1 ./$package_path/` && true || exit 1

            # short_commitish=0bf2b81
            short_commitish=`git log --pretty=format:'%h' -1 ./$package_path/` && true || exit 1

            # version=main.20230815-110805.0bf2b81
            # This version is not very accurate, after running `npm version`, it will remove leading zeroes in prerelease tags if that certain part is all numeric. This does not repro in semver.
            # "main.20230815-110805.0bf2b81" -> "main.20230815-110805.0bf2b81"
            # "main.20230815-110805.0012345" -> "main.20230815-110805.12345"
            # We will update the matrix again in build job.
            version=`cat ./$package_path/package.json | jq -r .version | xargs -L1 npm exec --offline -- semver --increment prerelease -n false --preid $branch.$committer_date.$short_commitish`

            cat /tmp/matrix.json | jq --arg path ./$package_path/ --arg version $version --argfile packageJSON ./$package_path/package.json -r '. + [{ name: $packageJSON.name, path: $path, private: ($packageJSON.private // false), version: $version }]' > /tmp/matrix.json.tmp
            mv /tmp/matrix.json.tmp /tmp/matrix.json
          done
      - name: 'Sanity check: matrix must have at least one entry'
        run: jq --argfile matrix /tmp/matrix.json -n 'if ($matrix | length) > 0 then empty else halt_error(1) end'
      - id: write-outputs
        name: Write to outputs
        run: echo matrix=`cat /tmp/matrix.json | jq -cr` | tee --append $GITHUB_OUTPUT

  build:
    name: Build (${{ matrix.scoped && 'scoped' || 'unscoped' }})
    needs: prepare
    outputs:
      # filenames: ['package-a-1.2.3-0.tgz', 'package-b-7.8.9-0.tgz']
      filenames: ${{ !matrix.scoped && steps.write-outputs.outputs.filenames || null }}
      # scoped-filenames: ['compulim-package-a-1.2.3-0.tgz', 'compulim-package-b-7.8.9-0.tgz']
      scoped-filenames: ${{ matrix.scoped && steps.write-outputs.outputs.filenames || null }}
      # versions: ['1.2.3-0', '7.8.9-0']
      versions: ${{ !matrix.scoped && steps.write-outputs.outputs.versions || null }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        # We are rescoping packages so they can publish to contributor's GitHub Packages so they can consume it easily.
        scoped: [true, false]
    steps:
      - env:
          matrix: ${{ needs.prepare.outputs.matrix }}
        name: Save matrix to file
        run: echo $matrix | jq -r | tee /tmp/matrix.json
      - uses: actions/checkout@v3
      - name: Set up Node.js ${{ env.node-version }}
        uses: actions/setup-node@v3
        with:
          cache: npm
          node-version: ${{ env.node-version }}
      - if: ${{ inputs.use-secure-feed }}
        name: Set up secure feed
        run: npx https://aka.ms/EnableSecureFeed
        shell: bash
      - # We cannot run "npm version" right after "npx semver". Otherwise, next run of "npx semver" will ignore "-n false".
        # "npm version" will update workspaces. During update, it will need to talk to NPM registry.
        name: Bump versions
        run: cat /tmp/matrix.json | jq -cr 'map("--workspace=" + .name + " " + .version) | join("\n")' | xargs -L1 npm version
      - run: npm clean-install --ignore-scripts --strict-peer-deps # CyberEO: Ignore scripts to prevent malicious scripts from stealing the token.
      - # We are cheating, we did not rescope package-lock.json, so we cannot run before npm clean-install.
        # TODO: Rescope package-lock.json
        if: ${{ matrix.scoped }}
        name: Rescope to @${{ github.repository_owner }}
        run: |
          for i in `cat package.json | jq -r '.workspaces | join("\n")'`
          do
            echo ::group::$i/package.json

            cat $i/package.json | jq --arg owner ${{ github.repository_owner }} --argfile matrix /tmp/matrix.json -r 'def rescope($entry): $entry | if ($matrix | map(select(.name == $entry.key)) | length > 0) then .value = "npm:@" + $owner + "/" + .key + "@" + .value else . end; . | (.name = "@" + $owner + "/" + .name) | (.dependencies |= (. | with_entries(rescope(.)))) | (.devDependencies |= (. | with_entries(rescope(.))))' | tee /tmp/package.json && true || exit 1

            mv /tmp/package.json $i/package.json && true || exit 1

            echo ::endgroup::
          done
      - name: Run whitelisted postinstall scripts
        run: npm run postinstall --if-present --workspaces=true
      - name: Build
        run: npm run build --if-present --workspaces=true
      - name: Pack
        run: |
          mkdir /tmp/tarball/ && true || exit 1
          npm pack --json --pack-destination=/tmp/tarball/ --workspaces=true | tee /tmp/pack-result.json && true || exit 1
      - name: 'Sanity check: pack-result.json should match package.json/workspaces'
        run: |
          cat /tmp/pack-result.json | jq 'map(del(.files))'

          count=`cat package.json | jq -r '.workspaces | length - 1'`

          for index in `seq 0 $count`
          do
            filename=`cat /tmp/pack-result.json | jq --argjson index $index -r '.[$index].filename'`
            package_path=`cat package.json | jq --argjson index $index -r '.workspaces[$index]'`

            echo ::group::$package_path

            package_name=`cat $package_path/package.json | jq -r .name`
            tarball_package_name=`tar -xf /tmp/tarball/$filename --to-stdout package/package.json | jq -r .name`

            echo "$package_name" should be same as "$tarball_package_name".

            echo ::endgroup::

            if [[ "$package_name" != "$tarball_package_name" ]]
            then
              exit 1
            fi
          done
      - id: write-outputs
        name: Write to outputs
        run: |
          compgen -G /tmp/pack-result.json && true || exit 1

          filenames=`cat /tmp/pack-result.json | jq -cr .filename`
          versions=`cat /tmp/pack-result.json | jq -cr .version`

          echo filenames=$filenames | tee --append $GITHUB_OUTPUT
          echo versions=$versions | tee --append $GITHUB_OUTPUT
      - if: ${{ !matrix.scoped }}
        name: Upload package-lock.json
        uses: actions/upload-artifact@v3
        with:
          if-no-files-found: error
          name: package-lock
          path: ./package-lock.json
      - name: Upload packages artifact
        uses: actions/upload-artifact@v3
        with:
          if-no-files-found: error
          name: ${{ matrix.scoped && 'scoped-packages' || 'packages' }}
          path: /tmp/tarball/

  build-github-pages:
    name: 'Build: GitHub Pages'
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download packages artifact
        uses: actions/download-artifact@v3
        with:
          name: packages
      - env:
          matrix: ${{ needs.build.outputs.matrix }}
        id: get-tarball-name
        name: Get tarball name
        run: |
          tarball=`echo $matrix | jq -r '.[] | select(.name == "pages") | .tarball | if . then . else halt_error(1) end'` && true || exit 1

          echo tarball=$tarball | tee --append $GITHUB_OUTPUT
      - name: Make directory
        run: mkdir ./_site/
      - name: Extract ${{ steps.get-tarball-name.outputs.tarball }}
        run: tar --directory=./_site/ --extract --file=`ls -1 ${{ steps.get-tarball-name.outputs.tarball }}` --strip-component=2 --verbose package/public
      - name: List directory
        run: ls -la ./_site/
      - name: Upload pages artifact
        uses: actions/upload-pages-artifact@v2

  pre-approval:
    name: Pre-approval
    needs:
      - build
      - build-github-pages
      - prepare
    outputs:
      matrix: ${{ steps.write-outputs.outputs.matrix }}
    runs-on: ubuntu-latest
    steps:
      - env:
          matrix: ${{ needs.prepare.outputs.matrix }}
        name: Save matrix to file
        run: echo $matrix | jq -r | tee /tmp/matrix.json
      - env:
          filenames: ${{ needs.build.outputs.filenames }}
        name: Add filename to matrix
        run: |
          echo $filenames | jq -r | tee /tmp/filenames.json

          cat /tmp/matrix.json | jq --argfile filenames /tmp/filenames.json -r '. | with_entries(.value += { filename: $filenames[.key] })' > /tmp/matrix.json.tmp && true || exit 1

          mv /tmp/matrix.json.tmp /tmp/matrix.json
      - env:
          scoped_filenames: ${{ needs.build.outputs.scoped-filenames }}
        name: Add scoped filenames to matrix
        run: |
          echo $scoped_filenames | jq -r | tee /tmp/scoped-filenames.json

          cat /tmp/matrix.json | jq --argfile scopedFilenames /tmp/scoped-filenames.json -r '. | with_entries(.value += { filename: $scopedFilenames[.key] })' > /tmp/matrix.json.tmp && true || exit 1

          mv /tmp/matrix.json.tmp /tmp/matrix.json
      - env:
          versions: ${{ needs.build.outputs.versions }}
        name: Add versions to matrix
        run: |
          echo $versions | jq -r | tee /tmp/versions.json

          cat /tmp/matrix.json | jq --argfile versions /tmp/versions.json -r '. | with_entries(.value += { filename: $versions[.key] })' > /tmp/matrix.json.tmp && true || exit 1

          mv /tmp/matrix.json.tmp /tmp/matrix.json
      - name: Print updated matrix
        run: cat /tmp/matrix.json
      - env:
          matrix: ${{ needs.prepare.outputs.matrix }}
        name: 'Sanity check: updated matrix must have same number of items'
        run: jq --argfile updated /tmp/matrix.json --argjson matrix $matrix -n 'if ($updated | length) == ($matrix | length) then empty else halt_error(1) end'
      - name: 'Sanity check: matrix must have "filename" field'
        run: cat /tmp/matrix.json | jq 'if (.[] | select(.filename | not) | length > 0) then halt_error(1) else empty end'
      - name: 'Sanity check: matrix must have "scopedFilename" field'
        run: cat /tmp/matrix.json | jq 'if (.[] | select(.scopedFilename | not) | length > 0) then halt_error(1) else empty end'
      - name: 'Sanity check: matrix must have "version" field'
        run: cat /tmp/matrix.json | jq 'if (.[] | select(.version | not) | length > 0) then halt_error(1) else empty end'
      - id: write-outputs
        name: Write to outputs
        run: echo matrix=`cat /tmp/matrix.json | jq -cr` | tee --append $GITHUB_OUTPUT

  approval:
    name: Approval
    needs: pre-approval
    outputs:
      matrix: ${{ steps.write-outputs.outputs.matrix }}
      public-only-matrix: ${{ steps.write-outputs.outputs.public-only-matrix }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - env:
          matrix: ${{ needs.pre-approval.outputs.matrix }}
        name: Save matrix to file
        run: echo $matrix | jq -r | tee /tmp/matrix.json
      - env:
          matrix: ${{ needs.pre-approval.outputs.matrix }}
        name: Save public-only matrix to file
        run: cat /tmp/matrix.json | jq -r 'map(select(.private | not))' | tee /tmp/public-only-matrix.json
      - id: write-outputs
        name: Write matrix to outputs
        run: |
          echo matrix=`cat /tmp/matrix.json | jq -cr` | tee --append $GITHUB_OUTPUT
          echo public-only-matrix=`cat /tmp/public-only-matrix.json | jq -cr` | tee --append $GITHUB_OUTPUT
      - name: Print approved matrix
        uses: ./.github/actions/print-step-summary-from-file
        with:
          path: /tmp/matrix.json
          title: Approved matrix
          type: json
      - name: Print approved public-only matrix
        uses: ./.github/actions/print-step-summary-from-file
        with:
          path: /tmp/public-only-matrix.json
          title: Approved public-only matrix
          type: json

  release-upload-matrix:
    name: 'Release: Upload matrix'
    needs: approval
    permissions:
      contents: write # "contents" is required for modifying releases.
    runs-on: ubuntu-latest
    steps:
      - env:
          matrix: ${{ needs.approval.outputs.matrix }}
        name: Save matrix to file
        run: echo $matrix > /tmp/matrix.json
      - env:
          GH_TOKEN: ${{ github.token }}
        name: Upload workflow state to GitHub "${{ env.publish-tag }}" release
        run: gh release upload --clobber ${{ env.publish-tag }} /tmp/matrix.json --repo ${{ github.repository }}

  release-upload-package:
    name: 'Release: Upload package'
    needs: approval
    permissions:
      contents: write # "contents" is required for modifying releases.
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include: ${{ fromJSON(needs.approval.outputs.public-only-matrix) }}
    steps:
      - name: Download packages
        uses: actions/download-artifact@v3
        with:
          name: packages
      - env:
          GH_TOKEN: ${{ github.token }}
        name: Get current assets
        run: gh release view ${{ env.publish-tag }} --json assets --repo ${{ github.repository }} | tee /tmp/assets.json
      - id: check-existence
        name: Check if asset already present
        run: |
          echo exist=`cat /tmp/assets.json | jq --arg name ${{ matrix.filename }} '.assets | any(select(.name == $name))'` | tee --append $GITHUB_OUTPUT

          if [[ exist == 'false' ]]
          then
            echo Asset does not exists, should upload.
          else
            echo Asset already exists, should not overwrite.
          fi
      - env:
          GH_TOKEN: ${{ github.token }}
        if: ${{ steps.check-existence.outputs.exist == 'false' }}
        name: Upload new asset
        run: gh release upload ${{ env.publish-tag }} ${{ matrix.filename }} --repo ${{ github.repository }}
      - env:
          GH_TOKEN: ${{ github.token }}
        if: ${{ steps.check-existence.outputs.exist == 'false' }}
        name: Delete obsoleted assets
        run: |
          for asset_name in `cat /tmp/assets.json | jq -r --arg name ${{ matrix.package-name }} '.assets | map(select(.name | test($name + "-[0-9]"))) | map(.name) | join("\n")'`
          do
            # Continue if failed to delete asset. It is not fatal and could be fixed in next run.
            gh release delete-asset ${{ env.publish-tag }} $asset_name --repo ${{ github.repository }} || true
            echo "Deleted \`$asset_name\`"
          done

  release-upload-pages:
    name: 'Release: Upload pages'
    needs: approval
    permissions:
      contents: write # "contents" is required for modifying releases.
    runs-on: ubuntu-latest
    steps:
      - name: Download pages
        uses: actions/download-artifact@v3
        with:
          name: github-pages
      - name: Rename to github-pages.tar
        run: mv artifact.tar github-pages.tar
      - env:
          GH_TOKEN: ${{ github.token }}
        name: Upload pages to GitHub "${{ env.publish-tag }}" release
        run: gh release upload --clobber ${{ env.publish-tag }} github-pages.tar --repo ${{ github.repository }}

  # Update release after re-pushing a new tag.
  release-publish:
    environment:
      name: github-release
      url: ${{ steps.write-outputs.outputs.url }}
    name: 'Release: Publish'
    needs:
      - release-upload-matrix
      - release-upload-package
      - release-upload-pages
    outputs:
      tag-url: ${{ steps.write-outputs.outputs.tag-url }}
      url: ${{ steps.write-outputs.outputs.url }}
    permissions:
      contents: write # "contents" is required for modifying releases.
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Fetch all tags.
      - continue-on-error: true
        name: Delete existing tag
        run: git tag -d ${{ env.publish-tag }}
      - name: Create new tag
        run: git tag ${{ env.publish-tag }}
      - continue-on-error: true
        name: Delete server tag
        run: git push origin :${{ env.publish-tag }}
      - name: Push tag
        run: git push origin ${{ env.publish-tag }}
      - env:
          GH_TOKEN: ${{ github.token }}
        name: Publish release
        run: gh release edit --draft=false --prerelease ${{ env.publish-tag }} --repo ${{ github.repository }}
      - id: write-outputs
        name: Write to outputs
        run: |
          echo tag-url=${{ github.server_url }}/${{ github.repository }}/tree/${{ env.publish-tag }} | tee --append $GITHUB_OUTPUT
          echo url=${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ env.publish-tag }} | tee --append $GITHUB_OUTPUT

  github-pages-deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    outputs:
      url: ${{ steps.deployment.outputs.page_url }}
    name: 'GitHub Pages: Deploy'
    needs: approval
    permissions:
      id-token: write
      pages: write
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v2

  github-packages-publish:
    environment:
      name: github-packages
      url: ${{ github.server_url }}/${{ github.repository_owner }}?tab=packages\&repo_name=${{ github.event.repository.name }}
    name: 'GitHub Packages: Publish'
    needs: approval
    permissions:
      packages: write
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include: ${{ fromJSON(needs.approval.outputs.matrix-public-only) }}
    steps:
      - name: Download packages
        uses: actions/download-artifact@v3
        with:
          name: scoped-packages
      - name: Set up Node.js ${{ env.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.node-version }}
          registry-url: https://npm.pkg.github.com/
      - run: ls -l ${{ matrix.filename }}
      - id: has-published
        name: Checks if ${{ matrix.name }}@${{ matrix.version }} is already published
        uses: ./.github/actions/check-if-package-has-published
        with:
          name: ${{ matrix.name }}
          registry-url: https://npm.pkg.github.com/
          token: ${{ github.token }}
          version: ${{ matrix.version }}
      - env:
          NODE_AUTH_TOKEN: ${{ github.token }}
        if: ${{ steps.has-published.outputs.published == 'false' }}
        name: Publish ${{ matrix.name }}@${{ matrix.version }}
        run: echo npm publish --json ${{ matrix.filename }}

  summary:
    if: ${{ always() }}
    name: Summary
    needs:
      - github-packages-publish
      - github-pages-deploy
      - release-publish
    runs-on: ubuntu-latest
    steps:
      - name: Post deployment
        run: |
          echo - [GitHub Packages]\(${{ github.server_url }}/${{ github.repository_owner }}?tab=packages\&repo_name=${{ github.event.repository.name }}\) >> $GITHUB_STEP_SUMMARY
          echo - [Pages]\(${{ needs.github-pages-deploy.outputs.url }}\) >> $GITHUB_STEP_SUMMARY
          echo - [Release]\(${{ needs.release-publish.outputs.url }}\) >> $GITHUB_STEP_SUMMARY
          echo - [Source code \(tagged\)]\(${{ needs.release-publish.outputs.tag-url }}\) >> $GITHUB_STEP_SUMMARY
