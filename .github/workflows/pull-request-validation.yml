name: Pull request validation

on:
  pull_request:
    branches:
      - main
  workflow_dispatch: {} # Run on-demand for testing workflow functionality.

jobs:
  sanity-check-root:
    name: 'Sanity check: root package'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      # This is based on assumptions in our toolchain.
      - name: 'Sanity check: package path must match their package name'
        run: |
          set -euo pipefail

          for path in `cat package.json | jq -r '.workspaces | join("\n")'`
          do
            cat ./$path/package.json | jq --arg packagePath "$path" -r 'if ("packages/" + .name) == $packagePath then empty else halt_error(1) end'
          done

      # This is based on assumptions in our toolchain.
      - name: 'Sanity check: package-lock.json must be version 3'
        run: set -euo pipefail && cat ./package-lock.json | jq 'if .lockfileVersion == 3 then empty else empty | halt_error(1) end'

      - name: 'Sanity check: registry must be https://registry.npmjs.org/'
        run: set -euo pipefail && cat ./package-lock.json | jq '.packages | with_entries(select(.value.link | not)) | with_entries(select(.value.resolved != null)) | with_entries(select(.value.resolved | startswith("https://registry.npmjs.org/") | not)) | if length > 0 then halt_error(1) else empty end'

  build:
    name: Build
    outputs:
      matrix: ${{ steps.write-outputs.outputs.matrix }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        node-version:
          - lts/Hydrogen
        os:
          - ubuntu-latest
          # - windows-latest
    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
          cache: npm
      - run: npm clean-install --ignore-scripts --strict-peer-deps # Prevents malicious scripts from stealing our token.
      - run: npm run postinstall --if-present --workspaces=true # Run whitelisted postinstall scripts.
      - name: Run static code analysis
        run: npm run precommit --workspaces=true
      - name: Build
        run: npm run build --if-present --workspaces=true
      - if: ${{ matrix.os == 'ubuntu-latest' }}
        name: Pack tarballs
        run: |
          set -euo pipefail

          mkdir /tmp/tarball
          npm pack --json --pack-destination=/tmp/tarball --workspaces=true > /tmp/pack-result.json
      - name: Print pack result
        run: set -euo pipefail && cat /tmp/pack-result.json | jq -r 'map(del(.files))'
      - if: ${{ matrix.os == 'ubuntu-latest' }}
        name: Upload tarball artifact
        uses: actions/upload-artifact@v3.1.1
        with:
          name: tarball
          path: /tmp/tarball/*.tgz
      - id: write-outputs
        if: ${{ matrix.os == 'ubuntu-latest' }}
        name: Write to outputs
        run: |
          set -euo pipefail && echo matrix=`cat /tmp/pack-result.json | jq -cr 'map({ filename: .filename, name: .name })'` | tee --append $GITHUB_OUTPUT

  test:
    env:
      matrix: ${{ needs.build.outputs.matrix }}
    name: Test
    needs: build
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include: ${{ fromJSON(needs.build.outputs.matrix) }}
        node-version:
          - lts/Hydrogen
        os:
          - ubuntu-latest
          # - windows-latest
    steps:
      - name: Write matrix to file
        run: set -euo pipefail && echo $matrix | tee /tmp/matrix.json
      - uses: actions/checkout@v3
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
      - run: npm clean-install --ignore-scripts --strict-peer-deps # Prevents malicious scripts from stealing our token.
      - run: npm run postinstall --if-present --workspaces=true # Run whitelisted postinstall scripts.
      - uses: actions/download-artifact@v3
        with:
          name: tarball
          path: /tmp/tarball/
      - name: Extract tarballs
        run: |
          set -euo pipefail

          cat /tmp/matrix.json | jq -r 'map("--directory=packages/" + .name + " --file=" + .filename) | join("\n")' | xargs -L1 echo tar --extract --strip-component=1 --verbose
      - name: Test
        run: npm test --if-present --workspace=${{ matrix.name }}

  sanity-check-package:
    env:
      matrix: ${{ needs.build.outputs.matrix }}
    name: 'Sanity check: ${{ matrix.name }}'
    needs: build
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include: ${{ fromJSON(needs.build.outputs.matrix) }}
    steps:
      - name: Write matrix to file
        run: set -euo pipefail && echo $matrix | tee /tmp/matrix.json
      - name: Download tarball artifact
        uses: actions/download-artifact@v3
        with:
          name: tarball
      - name: Extract tarball to root
        run: tar --extract --file=${{ matrix.filename }} --strip-components=1 --verbose
      - id: prepare
        name: Prepare
        run: echo is-private=`cat ./package.json | jq -r '.private // false'` | tee --append $GITHUB_OUTPUT
      - name: 'Sanity check: package name must not be scoped'
        # This is because our rescoping step in continuous deployment will not work if the package is already scoped, it just do plain concat.
        # We can support scoped package if we add that feature to our CD pipeline.
        run: set -euo pipefail && cat ./package.json | jq 'if .name | contains("@") then halt_error(1) else empty end'
      - if: ${{ steps.prepare.outputs.is-private != 'true' }}
        name: 'Sanity check: has LICENSE'
        run: '[[ -f ./LICENSE ]]'
      - if: ${{ steps.prepare.outputs.is-private != 'true' }}
        name: 'Sanity check: has README.md'
        run: '[[ -f ./README.md ]]'
      - if: ${{ steps.prepare.outputs.is-private != 'true' }}
        name: 'Sanity check: at least one exports'
        run: set -euo pipefail && cat ./package.json | jq '.exports | to_entries | if length == 0 then halt_error(1) else empty end'
      - if: ${{ steps.prepare.outputs.is-private != 'true' }}
        name: 'Sanity check: all exports exists'
        run: set -euo pipefail && cat ./package.json | jq '.exports | map(flatten) | flatten | .[]' | xargs -L1 test -f
      - if: ${{ steps.prepare.outputs.is-private != 'true' }}
        name: 'Sanity check: all exports has "types" condition'
        run: set -euo pipefail && cat ./package.json | jq '.exports | map(select(.types == null)) | if length > 0 then halt_error(1) else empty end'
      - if: ${{ steps.prepare.outputs.is-private != 'true' }}
        name: 'Sanity check: has source maps'
        # TODO: Check if abc.js has abc.js.map, instead of just *.js.map.
        run: compgen -G lib/**/*.js.map
      - if: ${{ steps.prepare.outputs.is-private != 'true' }}
        name: 'Sanity check: no lib/**/*.spec.*'
        run: '! compgen -G lib/**/*.spec.*'
      - if: ${{ steps.prepare.outputs.is-private != 'true' }}
        name: 'Sanity check: no lib/**/*.test.*'
        run: '! compgen -G lib/**/*.test.*'
      - name: 'Sanity check: no production dependencies are pre-release except local peers'
        run: |
          set -euo pipefail

          cat ./package.json | jq --argfile matrix /tmp/matrix.json '.dependencies + ($matrix | map({ key: .name }) | from_entries) | with_entries(select(.value // "" | contains("-"))) | if length > 0 then halt_error(1) else empty end'
      - name: 'Sanity check: version must be prerelease'
        run: set -euo pipefail && cat ./package.json | jq '.version | if contains("-") then empty else halt_error(1) end'
      - if: ${{ steps.prepare.outputs.is-private != 'true' }}
        name: 'Sanity check: package.json/files must contains at least one item'
        run: set -euo pipefail && cat ./package.json | jq '.files // [] | if length == 0 then halt_error(1) else empty end'
      # TODO: Must contains changes in CHANGELOG.md if it modified *.ts
      # TODO: In CHANGELOG.md, if breaking changes is modified, must bump major
      # TODO: In CHANGELOG.md, if features are removed, must bump major
      # TODO: In CHANGELOG.md, if features are added, must bump minor
      # TODO: In CHANGELOG.md, if bugs are fixed, must bump patch
